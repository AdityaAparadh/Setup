{
  "ChefForces": {
    "prefix": "codechef",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "// -----------------------------------------------------------------------------------------------",
      "",
      "//  +-------------------------------------------------------------------------------+",
      "//  |                                   MACROS                                      |",
      "//  +-------------------------------------------------------------------------------+",
      "",
      "#define endl '\\n'",
      "#define MOD 1000000007",
      "const int MAXN = 1e6 + 5;",
      "// #define MOD 998244353",
      "",
      "#define vi vector<int>",
      "#define vvi vector<vector<int>>",
      "#define vll vector<long long>",
      "#define vvll vector<vector<long long>>",
      "#define vs vector<string>",
      "#define pb push_back",
      "#define umap unordered_map",
      "#define uset unordered_set",
      "",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef long double ld;",
      "",
      "//  +-------------------------------------------------------------------------------+",
      "//  |                                   DEBUGGING                                   |",
      "//  +-------------------------------------------------------------------------------+",
      "",
      "",
      "void __print(int x) {cerr << x;}",
      "void __print(long x) {cerr << x;}",
      "void __print(long long x) {cerr << x;}",
      "void __print(unsigned x) {cerr << x;}",
      "void __print(unsigned long x) {cerr << x;}",
      "void __print(unsigned long long x) {cerr << x;}",
      "void __print(float x) {cerr << x;}",
      "void __print(double x) {cerr << x;}",
      "void __print(long double x) {cerr << x;}",
      "void __print(char x) {cerr << '\\'' << x << '\\'';}",
      "void __print(const char *x) {cerr << '\"' << x << '\"';}",
      "void __print(const string &x) {cerr << '\"' << x << '\"';}",
      "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
      "template<typename T, typename V>",
      "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
      "template<typename T>",
      "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
      "void _print() {cerr << \"]\\n\";}",
      "template <typename T, typename... V>",
      "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
      "#else",
      "#define debug(x...)",
      "#endif",
      "",
      "//  +-------------------------------------------------------------------------------+",
      "//  |                                   TEMPLATES                                   |",
      "//  +-------------------------------------------------------------------------------+",
      "",
      "",
      "",
      "",
      "",
      "// -----------------------------------------------------------------------------------------------",
      "",
      "void code(){",
      "",
      "",
      "    ${1}",
      "",
      "",
      "}",
      "",
      "",
      "",
      "// -----------------------------------------------------------------------------------------------",
      "",
      "int main(){",
      "",
      "    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
      "    int t; cin >> t;",
      "    while(t--){",
      "        code();",
      "    }",
      "}",
      "",
      "// -----------------------------------------------------------------------------------------------",
      ""
    ],
    "description": "ChefForces"
  },
  "input_loop": {
    "prefix": "in1",
    "body": [
      "int n; cin >> n;",
      "for( int i = 0 ; i < n ; i++ ){",
      "    int x; cin >> x;",
      "    $0",
      "}"
    ],
    "description": "C++ template with a oop for multiple test cases"
  },
  "input_loop2": {
    "prefix": "in2",
    "body": [
      "int n,m; cin >> n >> m;",
      "for( int i = 0 ; i < n ; i++ ){",
      "    int x; cin >> x;",
      "    $0",
      "}"
    ],
    "description": "C++ template with a loop for multiple test cases"
  },
  "vowelSet": {
    "prefix": "vowelSet",
    "body": [
      "unordered_set<char> vowels = {'a','e','i','o','u','A','E','I','O','U' };"
    ],
    "description": "A Hashset of Vowel Characters"
  },
  "rotateVector": {
    "prefix": "rotateVector",
    "body": "int rotateVector(vector<int>& v, int n){\n    int temp = v[0];\n    for(int i = 0; i < n; i++){\n        v[i] = v[i+1];\n    }\n    v[n-1] = temp;\n}",
    "description": "Function to rotate a vector by n"
  },
  "Sieve of Eratosthenes": {
    "prefix": "sieve",
    "body": [
      "vector<bool> prime(MAXN, true);",
      "void sieve() {",
      "    prime[0] = prime[1] = false;",
      "    for (int i = 2; i * i <= MAXN; i++) {",
      "        if (prime[i]) {",
      "            for (int j = i * i; j <= MAXN; j += i) {",
      "                prime[j] = false;",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Sieve of Eratosthenes"
  },
  "Sieve of Eratosthenes with Set": {
    "prefix": "sieveSet",
    "body": [
      "",
      "// Sieve of Eratosthenes(Set)",
      "set<int> sieveOfEratosthenes(int lower, int upper) {",
      "    if (upper < 2) return {};lower = max(lower, 2);",
      "    vector<bool> isPrime(upper + 1, true);",
      "    isPrime[0] = isPrime[1] = false;",
      "    for (int p = 2; p * p <= upper; p++) {",
      "        if (isPrime[p]) {",
      "            for (int multiple = p * p; multiple <= upper; multiple += p) { isPrime[multiple] = false; }",
      "        }",
      "    }",
      "    set<int> primeSet;",
      "    for (int num = lower; num <= upper; num++) {",
      "        if (isPrime[num]) {",
      "            primeSet.insert(num);",
      "        }",
      "    }",
      "    return primeSet;",
      "}"
    ],
    "description": "Sieve of Eratosthenes with Set"
  },
  "Prime Factorization": {
    "prefix": "primeFactorization",
    "body": [
      "// Requires SieveSet",
      "map<int, int> primeFactorization(int n, set<int>& primeSet) {",
      "    map<int, int> factors;",
      "    for (int prime : primeSet) {",
      "        if (prime * prime > n) break;  ",
      "        while (n % prime == 0) {",
      "            factors[prime]++;",
      "            n /= prime;",
      "        }",
      "    }",
      "    if (n > 1) {",
      "        factors[n] = 1;",
      "    }",
      "    return factors;",
      "}"
    ],
    "description": "Prime Factorization"
  },
  "Xor Upto N": {
    "prefix": "xor_upto",
    "body": [
      "ll xor_upto(ll n) {",
      "    if (n % 4 == 0) return n;",
      "    if (n % 4 == 1) return 1;",
      "    if (n % 4 == 2) return n + 1;",
      "    return 0;",
      "}"
    ],
    "description": "Xor Upto N"
  },
  "Range Xor": {
    "prefix": "range_xor",
    "body": [
      "// Requires xor_upto",
      "ll range_xor(ll l, ll r) {",
      "    return xor_upto(r) ^ xor_upto(l - 1);",
      "}"
    ],
    "description": "Xor Upto N"
  },
  "Modular Arithmetic": {
    "prefix": "modular_arithmetic",
    "body": [
      "ll mod_add(ll a, ll b, ll m) { return (((a + b) % m) + m) % m; }",
      "ll mod_sub(ll a, ll b, ll m) { return (((a - b) % m) + m) % m; }",
      "ll mod_mul(ll a, ll b, ll m) { return (((a * b) % m) + m) % m; }",
      "ll mod_inverse(ll a, ll m) { return binpowmod(a, m - 2, m); }  // for prime m",
      "ll mod_div(ll a, ll b, ll m) { return mod_mul(a, mod_inverse(b, m), m); }",
      "",
      "// Modular Exponentiation",
      "template <typename T> T binpowmod(T base, T exp, T mod) {",
      "    T result = 1;",
      "    base %= mod;",
      "    while (exp > 0) {",
      "        if (exp & 1) result = (result * base) % mod;",
      "        base = (base * base) % mod;",
      "        exp >>= 1;",
      "    }",
      "    return result;",
      "}"
    ],
    "description": "Modular Arithmetic"
  },
  "Modular Factorial": {
    "prefix": "mod_factorial",
    "body": [
      "vector<ll> fact(MAXN), inv_fact(MAXN);",
      "void factorial(ll mod) {",
      "    fact[0] = inv_fact[0] = 1;",
      "    for (int i = 1; i < MAXN; i++) {",
      "        fact[i] = fact[i - 1] * i % mod;",
      "        inv_fact[i] = mod_inverse(fact[i], mod);",
      "    }",
      "}"
    ],
    "description": "Modular Factorial"
  },
  "Modular Combinatorics": {
    "prefix": "mod_ncr",
    "body": [
      "// Required mod_factorial",
      "ll nCr(ll n, ll r, ll mod) {",
      "    if (r > n || r < 0) return 0;",
      "    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;",
      "}",
      ""
    ],
    "description": "Modular Combinatorics"
  },
  "Factorial Class for overflow avoidance": {
    "prefix": "classFactorial",
    "body": [
      "// Factorial class to performs operations on Factorials without overflow ",
      "class Factorial{",
      "    map<int, int> primeFactorization(int n, set<int>& primeSet) {",
      "        std::map<int, int> factors;",
      "        for (int prime : primeSet) {",
      "            if (prime * prime > n) break;  ",
      "            while (n % prime == 0) {",
      "                factors[prime]++;",
      "                n /= prime;",
      "            }",
      "        }",
      "        if (n > 1) {",
      "            factors[n] = 1;",
      "        }",
      "        return factors;",
      "    }",
      "int n;",
      "map<int,int> primeFactors;",
      "set<int> primeSet;",
      "public:",
      "    Factorial(int n, set<int> primeSet ){",
      "        this->n = n;",
      "        for( int i = 2 ; i<=n ; i++ ){",
      "            map<int,int> currentFactors = primeFactorization(i,primeSet);",
      "            for( auto it : currentFactors){",
      "                primeFactors[it.first] += it.second;",
      "            }",
      "        }",
      "    }",
      "    Factorial( map<int, int> primeFactors ){",
      "        this->primeFactors = primeFactors;",
      "    }",
      "    ll getValue(){",
      "        ll result = 1;",
      "        for( auto it : primeFactors ){",
      "            result *= pow(it.first,it.second);",
      "        }",
      "        return result;",
      "    }",
      "",
      "    map<int,int> getMap(){",
      "        return this->primeFactors;",
      "    }",
      "",
      "    ll operator+(Factorial m){",
      "        return this->getValue()+m.getValue();",
      "    }",
      "    ll operator+(int m){",
      "        return this->getValue()+m;",
      "    }",
      "    ll operator+(ll m){",
      "        return this->getValue()+m;",
      "    }",
      "    ll operator-(Factorial m){",
      "        return this->getValue()-m.getValue();",
      "    }",
      "    ll operator-(int m){",
      "        return this->getValue()-m;",
      "    }",
      "    ll operator-(ll m){",
      "        return this->getValue()-m;",
      "    }",
      "    Factorial operator*(Factorial m){",
      "        map<int,int> ans;",
      "        for( auto it : m.primeFactors ){",
      "            ans[it.first] += it.second;",
      "        }",
      "        for( auto it : this->primeFactors ){",
      "            ans[it.first] += it.second;",
      "        }",
      "        return ans;",
      "    }",
      "    Factorial operator/(Factorial m){",
      "        map<int,int> ans;",
      "        for( auto it : m.primeFactors ){",
      "            ans[it.first] -= it.second;",
      "        }",
      "        for( auto it : this->primeFactors ){",
      "            ans[it.first] += it.second;",
      "        }",
      "        return ans;",
      "    }",
      "};"
    ],
    "description": "Factorial Class for overflow avoidance"
  },
  "Subset Generation": {
    "prefix": "generateSubset",
    "body": [
      "vector<vector<int>> generateSubsets(const vector<int>& set) {",
      "    int n = set.size();",
      "    vector<vector<int>> superset;",
      "    for (int i = 0; i < (1 << n); ++i) {",
      "        vector<int> subset;",
      "        for (int j = 0; j < n; ++j) {",
      "            if (i & (1 << j)) {",
      "                subset.push_back(set[j]);",
      "            }",
      "        }",
      "        superset.push_back(subset);",
      "    }",
      "    return superset;",
      "}",
      ""
    ],
    "description": "Subset Generation"
  },
  "Permutation Generation": {
    "prefix": "generatePermutation",
    "body": [
      "vector<vector<int>> generatePermutations(vector<int> set) {",
      "    vector<vector<int>> allPermutations;",
      "    sort(set.begin(), set.end()); // Sort only necessary for lexicographical order",
      "    do {",
      "        allPermutations.push_back(set);",
      "    } while (next_permutation(set.begin(), set.end()));",
      "    return allPermutations;",
      "}"
    ],
    "description": "Permutation Generation"
  },
  "Binary Search Array": {
    "prefix": "BinarySearchArray",
    "body": [
      "template <typename T>",
      "int binary_search(const vector<T>& arr, T target) {",
      "    int left = 0, right = arr.size() - 1;",
      "    while (left <= right) {",
      "        int mid = left + (right - left) / 2;",
      "        if (arr[mid] == target) return mid;",
      "        else if (arr[mid] < target) left = mid + 1;",
      "        else right = mid - 1;",
      "    }",
      "    return -1;",
      "}"
    ],
    "description": "Binary Search Array"
  },
  "Binary Search Value": {
    "prefix": "BinarySearchValue",
    "body": [
      "ll binary_search(ll start, ll end, ll target) {",
      "    ll left = start, right = end;",
      "    while (left <= right) {",
      "        int mid = left + (right - left) / 2;",
      "        if (arr[mid] == target) return mid;",
      "        else if (arr[mid] < target) left = mid + 1;",
      "        else right = mid - 1;",
      "    }",
      "    return -1; //Configure as necessary",
      "}"
    ],
    "description": "Binary Search Value"
  },
  "Pair Comparator": {
    "prefix": "PairComparator",
    "body": [
      "struct PairComparator {",
      "    bool operator()(const pair<ll, ll>& p1, const pair<ll, ll>& p2) {",
      "        return p1.second > p2.second; // Configure this, currently minHeap",
      "    }",
      "};"
    ],
    "description": "Pair Comparator"
  },
  "Int Comparator": {
    "prefix": "IntComparator",
    "body": [
      "struct IntComparator{",
      "    bool operator()(const ll& p1, const ll& p2) {",
      "        return p1 > p2 ; // Min Heap",
      "        // return p1 < p2 ; // Max Heap",
      "    }",
      "};"
    ],
    "description": "Int Comparator"
  },
  "Pair Priority Queue": {
    "prefix": "pairPriorityQueue",
    "body": [
      "   // Requires PairComparator",
      "   priority_queue< pair<ll,ll>, vector<pair<ll,ll>>, PairComparator > pq"
    ],
    "description": "Pair Priority Queue"
  },
  "Integer Comparator (LL)": {
    "prefix": "intComparator",
    "body": [
      "   // Requires IntComparator",
      "   priority_queue<ll,vector<ll>, IntComparator> minHeap;",
      ""
    ],
    "description": "Integer Comparator (LL)"
  },
  "HammingInteger": {
    "prefix": "hammingInteger",
    "body": [
      "int hamming(int a, int b) {",
      "    return __builtin_popcount(a^b);",
      "}"
    ],
    "description": "HammingInteger"
  },
  "Hamming Distance in Binary Strings": {
    "prefix": "hammingStrings",
    "body": [
      "int hamming(string a, string b) {",
      "    int d = 0;",
      "    for (int i = 0; i < a.size(); i++) {",
      "        if (a[i] != b[i]) d++;",
      "    }",
      "    return d;",
      "}"
    ],
    "description": "Hamming Distance in Binary Strings"
  },
  "Decimal no. to Binary String": {
    "prefix": "decimalToBinary",
    "body": [
      "",
      " string DecimalToBinary(int num)",
      "{",
      "    string str;",
      "      while(num){",
      "      if(num & 1) // 1",
      "        str+='1';",
      "      else // 0",
      "        str+='0';",
      "      num>>=1; // Right Shift by 1  ",
      "    }    ",
      "      return str;",
      "}"
    ],
    "description": "Decimal no. to Binary String"
  },
  "Binary String to Decimal": {
    "prefix": "binaryToDecimal",
    "body": [
      "int binaryToDecimal(string str)",
      "{",
      "    int dec_num = 0;",
      "      int power = 0 ;",
      "    int n = str.length() ; ",
      "   ",
      "      for(int i = n-1 ; i>=0 ; i--){",
      "      if(str[i] == '1'){",
      "        dec_num += (1<<power) ;",
      "      }",
      "      power++ ; ",
      "    }",
      "   ",
      "    return dec_num;",
      "}"
    ],
    "description": "Binary String to Decimal"
  },
  "LeetCode Starter": {
    "prefix": "leetcode",
    "body": [
      "#include <bits/stdc++.h> ",
      "using namespace std; ",
      "",
      "",
      "//  +-------------------------------------------------------------------------------+\"",
      "//  |                                   TYPEDEFS                                    |\"",
      "//  +-------------------------------------------------------------------------------+\"",
      "",
      "const int MOD = 1e9 + 7;",
      "// const int MOD = 998244353;",
      "const int MAXN = 1e6 + 5;",
      "typedef long long ll;",
      "typedef long double ld;",
      "typedef unsigned long long ull;",
      "typedef vector<int> vi;",
      "typedef vector<vector<int>> vvi;",
      "typedef vector<long long> vll;",
      "typedef vector<vector<long long>> vvll;",
      "typedef vector<string> vs;",
      "",
      "",
      "//  +-------------------------------------------------------------------------------+\"",
      "//  |                                   SNIPPETS                                    |\"",
      "//  +-------------------------------------------------------------------------------+\"",
      "",
      "",
      "",
      "",
      "",
      "//  +-------------------------------------------------------------------------------+\"",
      "//  |                                   SOLUTION                                    |\"",
      "//  +-------------------------------------------------------------------------------+\"",
      "",
      "",
      "// +-------------------------------------------------------------------------------+\"",
      "",
      "     ${1}",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "// +-------------------------------------------------------------------------------+\"",
      "",
      "",
      ""
    ],
    "description": "LeetCode Starter"
  },
  "CSES": {
    "prefix": "cses",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "// -----------------------------------------------------------------------------------------------",
      "",
      "//  +-------------------------------------------------------------------------------+",
      "//  |                                   MACROS                                      |",
      "//  +-------------------------------------------------------------------------------+",
      "",
      "#define endl '\\n'",
      "#define MOD 1000000007",
      "const int MAXN = 1e6 + 5;",
      "// #define MOD 998244353",
      "",
      "#define vi vector<int>",
      "#define vvi vector<vector<int>>",
      "#define vll vector<long long>",
      "#define vvll vector<vector<long long>>",
      "#define vs vector<string>",
      "#define pb push_back",
      "#define umap unordered_map",
      "#define uset unordered_set",
      "",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef long double ld;",
      "",
      "//  +-------------------------------------------------------------------------------+",
      "//  |                                   DEBUGGING                                   |",
      "//  +-------------------------------------------------------------------------------+",
      "",
      "",
      "void __print(int x) {cerr << x;}",
      "void __print(long x) {cerr << x;}",
      "void __print(long long x) {cerr << x;}",
      "void __print(unsigned x) {cerr << x;}",
      "void __print(unsigned long x) {cerr << x;}",
      "void __print(unsigned long long x) {cerr << x;}",
      "void __print(float x) {cerr << x;}",
      "void __print(double x) {cerr << x;}",
      "void __print(long double x) {cerr << x;}",
      "void __print(char x) {cerr << '\\'' << x << '\\'';}",
      "void __print(const char *x) {cerr << '\"' << x << '\"';}",
      "void __print(const string &x) {cerr << '\"' << x << '\"';}",
      "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
      "template<typename T, typename V>",
      "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
      "template<typename T>",
      "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
      "void _print() {cerr << \"]\\n\";}",
      "template <typename T, typename... V>",
      "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
      "#else",
      "#define debug(x...)",
      "#endif",
      "",
      "//  +-------------------------------------------------------------------------------+",
      "//  |                                   TEMPLATES                                   |",
      "//  +-------------------------------------------------------------------------------+",
      "",
      "",
      "",
      "",
      "",
      "// -----------------------------------------------------------------------------------------------",
      "",
      "void code(){",
      "",
      "",
      "    ${1}",
      "",
      "",
      "}",
      "",
      "",
      "",
      "// -----------------------------------------------------------------------------------------------",
      "",
      "int main(){",
      "",
      "    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
      "    code();",
      "}",
      "",
      "// -----------------------------------------------------------------------------------------------",
      ""
    ],
    "description": "CSES"
  }
}
